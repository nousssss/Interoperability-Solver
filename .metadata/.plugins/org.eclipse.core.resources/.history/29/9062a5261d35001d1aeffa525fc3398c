package org.processmining.plugins.nouss;

import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;

import org.deckfour.xes.extension.XExtension;
import org.deckfour.xes.factory.XFactory;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.processmining.framework.util.Pair;
import org.processmining.models.connections.GraphLayoutConnection;
import org.processmining.models.graphbased.AbstractGraphElement;
import org.processmining.models.graphbased.directed.opennet.OpenNet;
import org.processmining.models.graphbased.directed.petrinet.PetrinetEdge;
import org.processmining.models.graphbased.directed.petrinet.PetrinetNode;
import org.processmining.models.graphbased.directed.petrinet.configurable.impl.ConfigurableResetInhibitorNet;
import org.processmining.models.graphbased.directed.petrinet.elements.ExpandableSubNet;
import org.processmining.models.graphbased.directed.petrinet.elements.Place;
import org.processmining.models.graphbased.directed.petrinet.elements.Transition;
import org.processmining.models.semantics.petrinet.Marking;
import org.processmining.plugins.pnml.base.Pnml;
import org.processmining.plugins.pnml.elements.PnmlNet;
import org.processmining.plugins.pnml.elements.extensions.configurations.PnmlConfiguration;
import org.processmining.plugins.pnml.elements.extensions.opennet.PnmlModule;

public class ModifiedPnml extends Pnml {
	
	
	private PnmlType type;

	/**
	 * net elements.
	 */
	private List<PnmlNet> netList;
	private PnmlModule module;
	private PnmlConfiguration configuration;

	private XLog log;
	private XTrace trace;
	private XFactory xFactory;
	private XExtension conceptExtension;
	private XExtension organizationalExtension;

	/**
	 * Converts the PNML object to a Petri net and initial marking.
	 * 
	 * @param net
	 *            Where to store the Petri net in (should be a fresh net).
	 * @param marking
	 *            Where to store the initial marking in (should be a fresh
	 *            marking).
	 */
	public void convertToNet(LabelledPetrinetGraph net, Marking marking, GraphLayoutConnection layout) {
		convertToNet(net, marking, new HashSet<Marking>(), layout);
	}

	public void convertToNet(LabelledPetrinetGraph net, Marking marking, Collection<Marking> finalMarkings,
			GraphLayoutConnection layout) {
		synchronized (factory) {
			if (net instanceof OpenNet) {
				if (module != null) {
					module.convertToOpenNet((OpenNet) net, marking, this, layout);
				}
			} else {
				if (!netList.isEmpty()) {
					Map<String, Place> placeMap = new HashMap<String, Place>();
					Map<String, Transition> transitionMap = new HashMap<String, Transition>();
					Map<String, PetrinetEdge<? extends PetrinetNode, ? extends PetrinetNode>> edgeMap = new HashMap<String, PetrinetEdge<?, ?>>();
					netList.get(0).convertToNet(net, marking, finalMarkings, placeMap, transitionMap, edgeMap, layout);
					setLayout(net, layout);
					if (net instanceof ConfigurableResetInhibitorNet && configuration != null) {
						configuration.convertToNet(net, placeMap, transitionMap, edgeMap);
					}
				}
			}
		}
	}

	public void setLayout(LabelledPetrinetGraph net, GraphLayoutConnection layout) {
		boolean doLayout = false;
		/*
		 * If any node has no position, then we need to layout the graph.
		 */
		for (PetrinetNode node : net.getNodes()) {
			if (layout.getPosition(node) == null) {
				doLayout = true;
			}
		}
		if (!doLayout) {
			/*
			 * All nodes have position (10.0,10.0) (which is the default
			 * position) we need to layout as well.
			 */
			doLayout = true;
			for (PetrinetNode node : net.getNodes()) {
				Point2D position = layout.getPosition(node);
				if ((position.getX() != 10.0) || (position.getY() != 10.0)) {
					doLayout = false;
				}
			}
		}
		layout.setLayedOut(!doLayout);
	}

	public String getLabel() {
		if (module != null) {
			return module.getName("Unlabeled net");
		} else if (!netList.isEmpty()) {
			return netList.get(0).getName("Unlabeled net");
		}
		return "Empty net";
	}

	public Pnml convertFromNet(Map<LabelledPetrinetGraph, Marking> markedNets, GraphLayoutConnection layout) {
		Map<LabelledPetrinetGraph, Collection<Marking>> finalMarkedNets = new HashMap<LabelledPetrinetGraph, Collection<Marking>>();
		for (LabelledPetrinetGraph net : markedNets.keySet()) {
			finalMarkedNets.put(net, new HashSet<Marking>());
		}
		return convertFromNet(markedNets, finalMarkedNets, layout);
	}

	public Pnml convertFromNet(Map<LabelledPetrinetGraph, Marking> markedNets,
			Map<LabelledPetrinetGraph, Collection<Marking>> finalMarkedNets, GraphLayoutConnection layout) {
		synchronized (factory) {
			netList = new ArrayList<PnmlNet>();
			int netCtr = 1;
			Map<Pair<AbstractGraphElement, ExpandableSubNet>, String> map = new HashMap<Pair<AbstractGraphElement, ExpandableSubNet>, String>();
			for (LabelledPetrinetGraph net : markedNets.keySet()) {

				netList.add(factory.createPnmlNet().convertFromNet(net, markedNets.get(net), finalMarkedNets.get(net),
						map, netCtr++, layout));
			}
			Map<AbstractGraphElement, String> idMap = new HashMap<AbstractGraphElement, String>();
			for (Pair<AbstractGraphElement, ExpandableSubNet> pair : map.keySet()) {
				idMap.put(pair.getFirst(), map.get(pair));
			}
			if (markedNets.keySet().size() == 1
					&& markedNets.keySet().iterator().next() instanceof ConfigurableResetInhibitorNet) {
				ConfigurableResetInhibitorNet configurableNet = (ConfigurableResetInhibitorNet) markedNets.keySet()
						.iterator().next();
				configuration = factory.createPnmlConfiguration();
				configuration.convertFromNet(configurableNet, idMap);
			}
			return this;
		}
	}

	public Pnml convertFromNet(LabelledPetrinetGraph net, Marking marking, GraphLayoutConnection layout) {
		return convertFromNet(net, marking, new HashSet<Marking>(), layout);
	}

	public Pnml convertFromNet(LabelledPetrinetGraph net, Marking marking, Collection<Marking> finalMarkings,
			GraphLayoutConnection layout) {
		Map<String, AbstractGraphElement> idMap = new HashMap<String, AbstractGraphElement>();
		return convertFromNet(net, marking, finalMarkings, idMap, layout);
	}

	public Pnml convertFromNet(LabelledPetrinetGraph net, Marking marking, Map<String, AbstractGraphElement> idMap,
			GraphLayoutConnection layout) {
		return convertFromNet(net, marking, new HashSet<Marking>(), idMap, layout);
	}

	public Pnml convertFromNet(LabelledPetrinetGraph net, Marking marking, Collection<Marking> finalMarkings,
			Map<String, AbstractGraphElement> idMap, GraphLayoutConnection layout) {
		synchronized (factory) {
			if (net instanceof OpenNet) {
				module = factory.createPnmlModule();
				module.convertFromOpenNet((OpenNet) net, marking, idMap, layout);
			} else {
				Map<Pair<AbstractGraphElement, ExpandableSubNet>, String> map = new HashMap<Pair<AbstractGraphElement, ExpandableSubNet>, String>();
				netList.add(factory.createPnmlNet().convertFromNet(net, marking, finalMarkings, map, 1, idMap, layout));
				Map<AbstractGraphElement, String> map2 = new HashMap<AbstractGraphElement, String>();
				for (Pair<AbstractGraphElement, ExpandableSubNet> pair : map.keySet()) {
					map2.put(pair.getFirst(), map.get(pair));
				}
				if (net instanceof ConfigurableResetInhibitorNet) {
					ConfigurableResetInhibitorNet configurableNet = (ConfigurableResetInhibitorNet) net;
					configuration = factory.createPnmlConfiguration();
					configuration.convertFromNet(configurableNet, map2);
				}
			}
			return this;
		}
	}

	public void setName(String name) {
		if (module != null) {
			module.setName(name);
		} else if (!netList.isEmpty()) {
			netList.get(0).setName(name);
		}
	}

}
